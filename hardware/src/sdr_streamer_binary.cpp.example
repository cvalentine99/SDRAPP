/**
 * sdr_streamer_binary.cpp.example - Enhanced SDR Streamer with Binary Protocol
 *
 * This example demonstrates the recommended improvements:
 * 1. Binary FFT output format (70% bandwidth reduction)
 * 2. Runtime parameter control via Unix domain socket
 * 3. Improved error handling and status reporting
 *
 * Build with: g++ -O3 -std=c++17 sdr_streamer_binary.cpp -o sdr_streamer_binary \
 *             -luhd -lboost_program_options -lboost_system -lfftw3f -lpthread
 */

#include <uhd/usrp/multi_usrp.hpp>
#include <uhd/utils/safe_main.hpp>
#include <uhd/utils/thread.hpp>
#include <fftw3.h>
#include <boost/program_options.hpp>
#include <boost/format.hpp>
#include <iostream>
#include <fstream>
#include <csignal>
#include <complex>
#include <vector>
#include <cmath>
#include <chrono>
#include <thread>
#include <atomic>
#include <mutex>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <fcntl.h>

namespace po = boost::program_options;

// ============================================================================
// Global state
// ============================================================================

static std::atomic<bool> stop_signal_called{false};
static std::atomic<double> target_frequency{915e6};
static std::atomic<double> target_gain{50.0};
static std::atomic<double> target_sample_rate{10e6};
static std::atomic<bool> params_changed{false};

void sig_int_handler(int) {
    stop_signal_called = true;
}

// ============================================================================
// B210 hardware limits
// ============================================================================

constexpr double B210_MIN_FREQ = 50e6;
constexpr double B210_MAX_FREQ = 6000e6;
constexpr double B210_MIN_RX_GAIN = 0.0;
constexpr double B210_MAX_RX_GAIN = 76.0;
constexpr double B210_MIN_BW = 200e3;
constexpr double B210_MAX_BW = 56e6;

// ============================================================================
// Binary protocol structures
// ============================================================================

#pragma pack(push, 1)

struct BinaryFFTHeader {
    uint32_t magic;           // 0x46465431 ("FFT1")
    uint32_t frame_number;
    double   timestamp;
    double   center_freq;
    double   sample_rate;
    uint16_t fft_size;
    uint16_t flags;           // Bit 0: GPS locked, Bit 1: Overflow
    int16_t  peak_bin;
    float    peak_power;
    // Followed by fft_size * sizeof(float) bytes of spectrum data
};
static_assert(sizeof(BinaryFFTHeader) == 44, "Header size mismatch");

struct BinaryStatusFrame {
    uint32_t magic;           // 0x53545431 ("STT1")
    uint32_t frame_count;
    float    rx_temp;
    float    tx_temp;
    uint8_t  gps_locked;
    uint8_t  pll_locked;
    uint16_t reserved;
    double   gps_servo;
    char     gps_time[32];
};
static_assert(sizeof(BinaryStatusFrame) == 56, "Status frame size mismatch");

// Control socket command
struct ControlCommand {
    enum Type : uint8_t {
        SET_FREQUENCY = 1,
        SET_SAMPLE_RATE = 2,
        SET_GAIN = 3,
        SET_BANDWIDTH = 4,
        GET_STATUS = 10,
        PING = 11,
        STOP = 255
    };
    Type type;
    double value;
};

struct ControlResponse {
    uint8_t success;
    double actual_value;
    char message[64];
};

#pragma pack(pop)

// ============================================================================
// Control socket server
// ============================================================================

constexpr char CONTROL_SOCKET_PATH[] = "/tmp/sdr_streamer.sock";

void control_socket_thread(uhd::usrp::multi_usrp::sptr usrp) {
    // Create Unix domain socket
    int server_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (server_fd < 0) {
        std::cerr << "[Control] Failed to create socket: " << strerror(errno) << std::endl;
        return;
    }

    // Set non-blocking for accept timeout
    int flags = fcntl(server_fd, F_GETFL, 0);
    fcntl(server_fd, F_SETFL, flags | O_NONBLOCK);

    sockaddr_un addr{};
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, CONTROL_SOCKET_PATH, sizeof(addr.sun_path) - 1);

    // Remove any existing socket file
    unlink(CONTROL_SOCKET_PATH);

    if (bind(server_fd, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) < 0) {
        std::cerr << "[Control] Failed to bind socket: " << strerror(errno) << std::endl;
        close(server_fd);
        return;
    }

    if (listen(server_fd, 5) < 0) {
        std::cerr << "[Control] Failed to listen: " << strerror(errno) << std::endl;
        close(server_fd);
        return;
    }

    std::cerr << "[Control] Socket listening at " << CONTROL_SOCKET_PATH << std::endl;

    while (!stop_signal_called) {
        // Accept with timeout
        fd_set read_fds;
        FD_ZERO(&read_fds);
        FD_SET(server_fd, &read_fds);

        timeval timeout{};
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;

        int ready = select(server_fd + 1, &read_fds, nullptr, nullptr, &timeout);
        if (ready <= 0) continue;

        int client_fd = accept(server_fd, nullptr, nullptr);
        if (client_fd < 0) continue;

        std::cerr << "[Control] Client connected" << std::endl;

        ControlCommand cmd;
        while (!stop_signal_called) {
            ssize_t bytes = recv(client_fd, &cmd, sizeof(cmd), 0);
            if (bytes != sizeof(cmd)) break;

            ControlResponse resp{};
            resp.success = 1;

            try {
                switch (cmd.type) {
                    case ControlCommand::SET_FREQUENCY:
                        if (cmd.value >= B210_MIN_FREQ && cmd.value <= B210_MAX_FREQ) {
                            target_frequency.store(cmd.value);
                            usrp->set_rx_freq(cmd.value);
                            resp.actual_value = usrp->get_rx_freq();
                            params_changed.store(true);
                            snprintf(resp.message, sizeof(resp.message),
                                    "Frequency set to %.6f MHz", resp.actual_value / 1e6);
                        } else {
                            resp.success = 0;
                            snprintf(resp.message, sizeof(resp.message),
                                    "Frequency out of range [%.0f-%.0f MHz]",
                                    B210_MIN_FREQ/1e6, B210_MAX_FREQ/1e6);
                        }
                        break;

                    case ControlCommand::SET_GAIN:
                        if (cmd.value >= B210_MIN_RX_GAIN && cmd.value <= B210_MAX_RX_GAIN) {
                            target_gain.store(cmd.value);
                            usrp->set_rx_gain(cmd.value);
                            resp.actual_value = usrp->get_rx_gain();
                            params_changed.store(true);
                            snprintf(resp.message, sizeof(resp.message),
                                    "Gain set to %.1f dB", resp.actual_value);
                        } else {
                            resp.success = 0;
                            snprintf(resp.message, sizeof(resp.message),
                                    "Gain out of range [%.0f-%.0f dB]",
                                    B210_MIN_RX_GAIN, B210_MAX_RX_GAIN);
                        }
                        break;

                    case ControlCommand::SET_SAMPLE_RATE:
                        // Sample rate changes require stream restart
                        target_sample_rate.store(cmd.value);
                        params_changed.store(true);
                        resp.actual_value = cmd.value;
                        snprintf(resp.message, sizeof(resp.message),
                                "Sample rate will change to %.2f MSPS", cmd.value / 1e6);
                        break;

                    case ControlCommand::PING:
                        resp.actual_value = 0;
                        snprintf(resp.message, sizeof(resp.message), "pong");
                        break;

                    case ControlCommand::STOP:
                        stop_signal_called = true;
                        snprintf(resp.message, sizeof(resp.message), "Stopping...");
                        break;

                    default:
                        resp.success = 0;
                        snprintf(resp.message, sizeof(resp.message), "Unknown command");
                }
            } catch (const std::exception& e) {
                resp.success = 0;
                snprintf(resp.message, sizeof(resp.message), "Error: %s", e.what());
            }

            send(client_fd, &resp, sizeof(resp), 0);
            std::cerr << "[Control] " << resp.message << std::endl;
        }

        close(client_fd);
        std::cerr << "[Control] Client disconnected" << std::endl;
    }

    close(server_fd);
    unlink(CONTROL_SOCKET_PATH);
    std::cerr << "[Control] Socket closed" << std::endl;
}

// ============================================================================
// FFT output functions
// ============================================================================

void output_json_fft(uint32_t frame_num, double timestamp, double freq, double rate,
                     size_t fft_size, int16_t peak_bin, float peak_power,
                     const std::vector<float>& spectrum) {
    std::cout << "{\"type\":\"fft\",\"timestamp\":" << timestamp
              << ",\"centerFreq\":" << freq
              << ",\"sampleRate\":" << rate
              << ",\"fftSize\":" << fft_size
              << ",\"peakPower\":" << peak_power
              << ",\"peakBin\":" << peak_bin
              << ",\"data\":[";

    for (size_t i = 0; i < fft_size; i++) {
        std::cout << spectrum[i];
        if (i < fft_size - 1) std::cout << ",";
    }
    std::cout << "]}" << std::endl;
}

void output_binary_fft(uint32_t frame_num, double timestamp, double freq, double rate,
                       size_t fft_size, int16_t peak_bin, float peak_power,
                       const std::vector<float>& spectrum, uint16_t flags) {
    BinaryFFTHeader header{};
    header.magic = 0x46465431;  // "FFT1"
    header.frame_number = frame_num;
    header.timestamp = timestamp;
    header.center_freq = freq;
    header.sample_rate = rate;
    header.fft_size = static_cast<uint16_t>(fft_size);
    header.flags = flags;
    header.peak_bin = peak_bin;
    header.peak_power = peak_power;

    // Write header
    fwrite(&header, sizeof(header), 1, stdout);
    // Write spectrum data
    fwrite(spectrum.data(), sizeof(float), fft_size, stdout);
    fflush(stdout);
}

void output_binary_status(uint32_t frame_count, float rx_temp, float tx_temp,
                          bool gps_locked, double gps_servo, const std::string& gps_time) {
    BinaryStatusFrame status{};
    status.magic = 0x53545431;  // "STT1"
    status.frame_count = frame_count;
    status.rx_temp = rx_temp;
    status.tx_temp = tx_temp;
    status.gps_locked = gps_locked ? 1 : 0;
    status.pll_locked = 1;  // Assume locked if streaming
    status.gps_servo = gps_servo;
    strncpy(status.gps_time, gps_time.c_str(), sizeof(status.gps_time) - 1);

    fwrite(&status, sizeof(status), 1, stdout);
    fflush(stdout);
}

// ============================================================================
// Main
// ============================================================================

int UHD_SAFE_MAIN(int argc, char *argv[]) {
    uhd::set_thread_priority_safe();

    // Command line options
    std::string device_args, subdev, ant, ref, clock_source;
    double freq, rate, gain, bw;
    size_t fft_size;
    bool use_gpsdo, binary_mode;

    po::options_description desc("SDR Streamer Options");
    desc.add_options()
        ("help", "Show help message")
        ("args", po::value<std::string>(&device_args)->default_value(""), "UHD device args")
        ("freq", po::value<double>(&freq)->default_value(915e6), "RF center frequency (Hz)")
        ("rate", po::value<double>(&rate)->default_value(10e6), "Sample rate (Hz)")
        ("gain", po::value<double>(&gain)->default_value(50), "RX gain (dB)")
        ("bw", po::value<double>(&bw)->default_value(10e6), "Analog bandwidth (Hz)")
        ("ant", po::value<std::string>(&ant)->default_value("RX2"), "Antenna selection")
        ("subdev", po::value<std::string>(&subdev)->default_value("A:A"), "Subdevice spec")
        ("ref", po::value<std::string>(&ref)->default_value("internal"), "Reference source")
        ("clock", po::value<std::string>(&clock_source)->default_value("internal"), "Clock source")
        ("fft-size", po::value<size_t>(&fft_size)->default_value(2048), "FFT size")
        ("gpsdo", po::value<bool>(&use_gpsdo)->default_value(true), "Use GPSDO if available")
        ("binary", po::value<bool>(&binary_mode)->default_value(false), "Binary output mode")
    ;

    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, desc), vm);
    po::notify(vm);

    if (vm.count("help")) {
        std::cout << desc << std::endl;
        return EXIT_SUCCESS;
    }

    // Set output mode for binary
    if (binary_mode) {
        // Ensure stdout is binary
        #ifdef _WIN32
        _setmode(_fileno(stdout), _O_BINARY);
        #endif
        std::cerr << "[SDR] Binary output mode enabled" << std::endl;
    }

    // Validate parameters
    if (freq < B210_MIN_FREQ || freq > B210_MAX_FREQ) {
        std::cerr << "Error: Frequency out of range" << std::endl;
        return EXIT_FAILURE;
    }
    if (gain < B210_MIN_RX_GAIN || gain > B210_MAX_RX_GAIN) {
        std::cerr << "Error: Gain out of range" << std::endl;
        return EXIT_FAILURE;
    }

    // Initialize atomic parameters
    target_frequency.store(freq);
    target_gain.store(gain);
    target_sample_rate.store(rate);

    // Create USRP device
    std::cerr << "[SDR] Creating B210 device..." << std::endl;
    uhd::usrp::multi_usrp::sptr usrp = uhd::usrp::multi_usrp::make(device_args);

    // Configure clock/time source
    bool gps_locked = false;
    if (use_gpsdo) {
        try {
            auto sensors = usrp->get_mboard_sensor_names(0);
            bool has_gpsdo = std::find(sensors.begin(), sensors.end(), "gps_locked") != sensors.end();

            if (has_gpsdo) {
                std::cerr << "[SDR] GPSDO detected, configuring..." << std::endl;
                usrp->set_clock_source("gpsdo");
                usrp->set_time_source("gpsdo");

                std::cerr << "[SDR] Waiting for GPS lock..." << std::endl;
                auto start = std::chrono::steady_clock::now();
                while (!usrp->get_mboard_sensor("gps_locked").to_bool()) {
                    auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
                        std::chrono::steady_clock::now() - start).count();
                    if (elapsed > 300) {
                        std::cerr << "[SDR] GPS lock timeout, using internal reference" << std::endl;
                        usrp->set_clock_source("internal");
                        usrp->set_time_source("internal");
                        break;
                    }
                    std::this_thread::sleep_for(std::chrono::seconds(1));
                }
                gps_locked = usrp->get_mboard_sensor("gps_locked").to_bool();
                if (gps_locked) {
                    std::cerr << "[SDR] GPS locked!" << std::endl;
                }
            }
        } catch (const std::exception& e) {
            std::cerr << "[SDR] GPSDO error: " << e.what() << std::endl;
            usrp->set_clock_source(clock_source);
            usrp->set_time_source(ref);
        }
    } else {
        usrp->set_clock_source(clock_source);
        usrp->set_time_source(ref);
    }

    // Configure RX
    usrp->set_rx_subdev_spec(subdev);
    usrp->set_rx_rate(rate);
    usrp->set_rx_freq(freq);
    usrp->set_rx_gain(gain);
    usrp->set_rx_bandwidth(bw);
    usrp->set_rx_antenna(ant);

    std::this_thread::sleep_for(std::chrono::seconds(1));

    std::cerr << boost::format("[SDR] Actual Rate: %.2f MSPS") % (usrp->get_rx_rate()/1e6) << std::endl;
    std::cerr << boost::format("[SDR] Actual Freq: %.6f MHz") % (usrp->get_rx_freq()/1e6) << std::endl;
    std::cerr << boost::format("[SDR] Actual Gain: %.1f dB") % usrp->get_rx_gain() << std::endl;

    // Start control socket thread
    std::thread control_thread(control_socket_thread, usrp);

    // Setup streaming
    uhd::stream_args_t stream_args("fc32", "sc16");
    uhd::rx_streamer::sptr rx_stream = usrp->get_rx_stream(stream_args);

    uhd::stream_cmd_t stream_cmd(uhd::stream_cmd_t::STREAM_MODE_START_CONTINUOUS);
    stream_cmd.stream_now = true;
    rx_stream->issue_stream_cmd(stream_cmd);

    // Allocate buffers
    std::vector<std::complex<float>> buffer(fft_size);
    std::vector<std::complex<float>*> buffs{buffer.data()};

    // FFTW setup
    fftwf_complex* fft_in = fftwf_alloc_complex(fft_size);
    fftwf_complex* fft_out = fftwf_alloc_complex(fft_size);
    fftwf_plan plan = fftwf_plan_dft_1d(fft_size, fft_in, fft_out, FFTW_FORWARD, FFTW_MEASURE);

    // Hann window
    std::vector<float> window(fft_size);
    for (size_t i = 0; i < fft_size; i++) {
        window[i] = 0.5f * (1.0f - std::cos(2.0f * M_PI * i / (fft_size - 1)));
    }

    // Signal handlers
    std::signal(SIGINT, &sig_int_handler);
    std::signal(SIGTERM, &sig_int_handler);

    uhd::rx_metadata_t md;
    uint32_t frame_count = 0;
    auto last_status_time = std::chrono::steady_clock::now();
    std::vector<float> power_db(fft_size);

    std::cerr << "[SDR] Streaming started..." << std::endl;

    while (!stop_signal_called) {
        // Receive samples
        size_t num_rx_samps = rx_stream->recv(buffs, fft_size, md, 3.0);

        // Handle errors
        if (md.error_code == uhd::rx_metadata_t::ERROR_CODE_TIMEOUT) {
            std::cerr << "[SDR] Timeout" << std::endl;
            continue;
        }
        if (md.error_code != uhd::rx_metadata_t::ERROR_CODE_NONE) {
            std::cerr << "[SDR] Error: " << md.strerror() << std::endl;
            continue;
        }

        if (num_rx_samps < fft_size) {
            continue;
        }

        // Apply window and copy to FFT input
        for (size_t i = 0; i < fft_size; i++) {
            fft_in[i][0] = buffer[i].real() * window[i];
            fft_in[i][1] = buffer[i].imag() * window[i];
        }

        // Compute FFT
        fftwf_execute(plan);

        // Compute power spectrum (dBFS) with FFT shift
        float peak_power = -200.0f;
        int16_t peak_bin = 0;

        for (size_t i = 0; i < fft_size; i++) {
            size_t j = (i + fft_size/2) % fft_size;
            float real = fft_out[j][0];
            float imag = fft_out[j][1];
            float power = (real*real + imag*imag) / (fft_size * fft_size);
            power_db[i] = 10.0f * std::log10(power + 1e-20f);

            if (power_db[i] > peak_power) {
                peak_power = power_db[i];
                peak_bin = static_cast<int16_t>(i);
            }
        }

        // Output FFT data
        uint16_t flags = gps_locked ? 0x0001 : 0x0000;
        double current_freq = target_frequency.load();
        double current_rate = target_sample_rate.load();

        if (binary_mode) {
            output_binary_fft(frame_count, md.time_spec.get_real_secs(),
                             current_freq, current_rate, fft_size,
                             peak_bin, peak_power, power_db, flags);
        } else {
            output_json_fft(frame_count, md.time_spec.get_real_secs(),
                           current_freq, current_rate, fft_size,
                           peak_bin, peak_power, power_db);
        }

        frame_count++;

        // Periodic status update (every 10 seconds)
        auto now = std::chrono::steady_clock::now();
        if (std::chrono::duration_cast<std::chrono::seconds>(now - last_status_time).count() >= 10) {
            float rx_temp = 0.0f, tx_temp = 0.0f;
            std::string gps_time = "unavailable";
            double gps_servo = 0.0;

            try {
                rx_temp = std::stof(usrp->get_rx_sensor("temp").value);
                tx_temp = std::stof(usrp->get_tx_sensor("temp").value);
                if (gps_locked) {
                    gps_locked = usrp->get_mboard_sensor("gps_locked").to_bool();
                    gps_time = usrp->get_mboard_sensor("gps_time").value;
                    gps_servo = std::stod(usrp->get_mboard_sensor("gps_servo").value);
                }
            } catch (...) {}

            if (binary_mode) {
                output_binary_status(frame_count, rx_temp, tx_temp, gps_locked, gps_servo, gps_time);
            } else {
                std::cout << "{\"type\":\"status\""
                          << ",\"frames\":" << frame_count
                          << ",\"gpsLocked\":" << (gps_locked ? "true" : "false")
                          << ",\"gpsTime\":\"" << gps_time << "\""
                          << ",\"gpsServo\":" << gps_servo
                          << ",\"rxTemp\":" << rx_temp
                          << ",\"txTemp\":" << tx_temp
                          << "}" << std::endl;
            }

            last_status_time = now;
        }
    }

    // Cleanup
    stream_cmd.stream_mode = uhd::stream_cmd_t::STREAM_MODE_STOP_CONTINUOUS;
    rx_stream->issue_stream_cmd(stream_cmd);

    fftwf_destroy_plan(plan);
    fftwf_free(fft_in);
    fftwf_free(fft_out);

    control_thread.join();

    std::cerr << "[SDR] Streaming stopped cleanly" << std::endl;
    return EXIT_SUCCESS;
}
